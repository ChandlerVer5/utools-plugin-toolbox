<head>

  <title>CSS Clip Path Generator | UnusedCSS</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="description"
    content="CSS clip-path maker with unlimited points, snapping, undo. Go freeform or use one of the example shapes such as a triangle, arrow or checkerboard.">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="./static/css/styles-logged-out.d2a04c522496.css">

  <link href="./static/css/tools.608c3ab69932.css" rel="stylesheet" type="text/css" media="all" />
  <style>
    .toolbar {
      background: white;
      padding: 5px;
      border-radius: 5px 5px 0 0;
      box-shadow: 0 0 20px rgb(0 0 0 / 30%);
      position: fixed;
      z-index: 1000;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      max-width: 100%;
      overflow-x: auto;
    }

    .toolbar .btn-group {
      display: flex;
    }

    .toolbar .btn-group:not(:first-child) {
      margin-left: 5px;
    }

    .toolbar .undo-icon {
      transform: scaleX(-1);
    }

    .footer {
      padding-bottom: 55px;
    }

    .content {
      padding-bottom: 150px;
    }

    .colorpicker.colorpicker-2x {
      width: 300px;
    }

    .colorpicker.colorpicker-2x.colorpicker-inline {
      width: 100%;
      border: 0;
      padding: 0;
      margin-top: 10px;
      box-shadow: none;
    }

    .colorpicker-2x .colorpicker-saturation {
      width: calc(100% - 72px);
      height: 200px;
    }

    .colorpicker-2x .colorpicker-hue,
    .colorpicker-2x .colorpicker-alpha {
      width: 30px;
      height: 200px;
    }

    .colorpicker-2x .colorpicker-alpha,
    .colorpicker-2x .colorpicker-preview {
      background-size: 20px 20px;
      background-position: 0 0, 10px 10px;
    }

    .colorpicker-2x .colorpicker-preview,
    .colorpicker-2x .colorpicker-preview div {
      height: 30px;
      font-size: 16px;
      line-height: 160%;
    }

    .colorpicker-saturation .colorpicker-guide {
      height: 10px;
      width: 10px;
      border-radius: 10px;
      margin: -5px 0 0 -5px;
    }

    div.colorpicker-saturation {
      background: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 1) 100%),
        linear-gradient(to right, rgba(255, 255, 255, 1) 0%, rgba(255, 255, 255, 0) 100%);
      /* W3C */
    }

    div.colorpicker-alpha {
      position: relative;
      background-image: none;
    }

    div.colorpicker-alpha::after {
      content: " ";
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      -webkit-mask-image: linear-gradient(to top, rgb(0, 0, 0) 0%, transparent 100%);
      mask-image: linear-gradient(to top, rgb(0, 0, 0) 0%, transparent 100%);
      background: linear-gradient(45deg, rgba(0, 0, 0, 0.1) 25%, rgba(0, 0, 0, 0) 25%, rgba(0, 0, 0, 0) 75%, rgba(0, 0, 0, 0.1) 75%, rgba(0, 0, 0, 0.1) 0) 0 0/10px 10px,
        linear-gradient(45deg, rgba(0, 0, 0, 0.1) 25%, rgba(0, 0, 0, 0) 25%, rgba(0, 0, 0, 0) 75%, rgba(0, 0, 0, 0.1) 75%, rgba(0, 0, 0, 0.1) 0) 5px 5px/10px 10px white;
      z-index: 1;
    }

    div.colorpicker-saturation i {
      margin: -2px 0 0 -2px;
      border: 1px solid white;
      box-shadow: 0 0 0 2px rgb(0, 0, 0, 0.1);
    }

    div.colorpicker .colorpicker-alpha i,
    div.colorpicker .colorpicker-hue i {
      z-index: 2;
      box-shadow: 0 0 0 1px rgb(0, 0, 0, 0.1);
    }

    div.colorpicker-saturation i b {
      display: none;
    }

    #preview-container {
      border: 1px solid #ccc;
      min-height: 300px;
      padding: 0;
      position: relative;
    }

    #grid {
      position: absolute;
      overflow: hidden;
      width: 100%;
      height: 100%;
      display: none;
    }

    #grid,
    #grid * {
      pointer-events: none;
    }

    #grid .circle {
      position: absolute;
      border-radius: 50%;
      box-shadow: 0 0 0 0.25px #ddd, inset 0 0 0 0.25px #ddd;
    }

    #grid .circle.highlight {
      box-shadow: 0 0 0 0.5px #ddd,
        inset 0 0 0 0.5px #ddd,
        0 0 0 2.5px rgba(0, 0, 255, 0.05),
        0 0 0 2.5px rgba(0, 0, 255, 0.05) inset;
    }

    #grid .line {
      position: absolute;
      transform-origin: 0 0;
      width: 1px;
      height: 10000px;
      background: #ddd;
    }

    #grid .line.highlight {
      box-shadow: 0 0 0 5px rgba(0, 0, 255, 0.05);
      width: 2px;
    }

    #grid .line.highlight[data-onlyhighlight=true] {
      box-shadow: none;
      background: #f0f;
      width: 4px;
    }

    #grid .right-angle {
      position: absolute;
      transform-origin: 0 0;
      width: 15px;
      height: 15px;
      border-right: 2px solid #ddd;
      border-bottom: 2px solid #ddd;
    }

    #grid .right-angle.highlight {
      box-shadow: 0 0 0 5px rgba(0, 0, 255, 0.05);
    }

    #grid .right-angle.highlight[data-onlyhighlight=true] {
      box-shadow: none;
      border-color: #f0f;
    }

    #grid .point {
      position: absolute;
      border: 2px solid #ddd;
      border-radius: 50%;
      margin: -2px;
    }

    #grid .point.highlight {
      box-shadow: 0 0 0 15px rgba(0, 0, 255, 0.05);
    }

    #grid .point.highlight[data-onlyhighlight=true] {
      border: 4px solid rgb(255, 0, 255);
      margin: -4px;
      box-shadow: none;
    }

    #grid .highlight[data-onlyhighlight=true] {
      z-index: 2;
    }

    #grid .highlight {
      z-index: 1;
    }

    #selection {
      display: none;
      position: absolute;
      background: linear-gradient(90deg, #ccc 50%, transparent 50%), linear-gradient(90deg, #ccc 50%, transparent 50%), linear-gradient(0deg, #ccc 50%, transparent 50%), linear-gradient(0deg, #ccc 50%, transparent 50%);
      background-repeat: repeat-x, repeat-x, repeat-y, repeat-y;
      background-size: 8px 1px, 8px 1px, 1px 8px, 1px 8px;
      animation: rotate-border 0.5s infinite linear;
      z-index: 3;
    }

    @keyframes rotate-border {
      0% {
        background-position: 0 0, 0 100%, 0 0, 100% 0;
      }

      100% {
        background-position: 8px 0, -8px 100%, 0 -8px, 100% 8px;
      }
    }

    .drag-handle {
      z-index: 1;
      background: #ddd;
      border: 1px solid #333;
      width: 20px;
      height: 20px;
      margin: -10px;
      position: absolute;
      border-radius: 50%;
      opacity: 0.25;
    }

    .drag-handle.dragging {
      opacity: 0.75;
    }

    .mouse-down #shape {
      opacity: 0.5;
    }

    #shape {
      position: absolute;
      /* Just to stop it resizing the parent div */
      transform-origin: 0 0;
    }

    #shape.dragging~.drag-handle {
      opacity: 0.75;
    }

    #shift-hint {
      display: none;
    }

    .no-touch #shift-hint {
      display: initial;
    }

    .drag-handle.selected {
      opacity: 1;
    }


    #output-pre {
      box-shadow: 0 0 0 0 transparent;
      transition: box-shadow 0.2s linear;
      background: white;
    }

    #output-pre.valid:focus {
      box-shadow: 0 0 0 4px #5cb85c;
    }

    #output-pre.invalid {
      box-shadow: 0 0 0 4px #d9534f;
    }


    #shape {
      background: black;
      width: 100%;
      height: 100%;
    }

    #background {
      display: none;
    }

    #preview-container {
      margin-left: auto;
      margin-right: auto;
      max-width: 100%;
      max-height: 100%;
      width: 402px;
      height: 402px;
      background: white;
      z-index: 1;
    }

    .drag-handle .delete-button {
      visibility: hidden;
      position: absolute;
      z-index: 1;
      top: 100%;
      border: 1px solid #ddd;
      margin-top: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: white;
      border-radius: 4px;
      padding: 5px;
    }

    .drag-handle .delete-button::before {
      content: " ";
      border-width: 0 8px 8px 8px;
      border-color: transparent transparent #ddd;
      border-style: solid;
      top: -8px;
      left: 50%;
      transform: translateX(-50%);
      position: absolute;
    }

    .drag-handle:focus .delete-button {
      visibility: visible;
    }

    .example {
      width: 100px;
      height: 100px;
      position: relative;
      margin-bottom: 30px;
      padding: 0;
    }

    .example-preview {
      width: 100%;
      height: 100%;
      background: black;
      display: block;
    }

    .example-name {
      position: absolute;
      top: 100%;
      margin-top: 3px;
      left: 0;
      width: 100%;
      text-align: center;
      white-space: normal;
    }

    #cp2 {
      max-width: 150px;
    }

    .colorpicker.colorpicker-2x {
      width: 300px;
    }

    .drag-handle:hover {
      opacity: 0.5;
    }

    .drag-handle.selected:hover {
      opacity: 1;
    }

    .drag-handle.text-hover {
      opacity: 1;
    }

    .handle-text {
      border-bottom-style: solid;
      border-bottom-width: 0;
    }

    .handle-text.hovered,
    .handle-text:hover {
      border-bottom-width: 1px;
    }

    .handle-text.selected {
      border-bottom-width: 2px;
    }

    #background-image {
      opacity: 0;
      position: absolute;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .mouse-down #background-image {
      opacity: 0.1;
    }
  </style>

</head>

<body>
  <div class="content container has-sidebar">

    <div class="row">
      <div class="col-xs-12">
        <h1>CSS Clip Path Generator</h1>
        <p>This tool will help you generate a CSS clip-path. It automatically generates a grid with useful snapping
          points so you can create interesting shapes. Drag from the middle of a line to add a new point.</p>
      </div>
    </div>
    <div class="row">
      <div class="col-md-4">
        <div class="panel panel-default">
          <div class="panel-heading">Settings</div>
          <div class="panel-body">

            <div class="form-inline form-horizontal form-group">
              <label class="control-label">Background Image</label>
              <input type="file" id="background" onchange="loadFile()" />
              <label class="control-label btn btn-default pull-right" for="background">Open</label>
            </div>
            <div class="form-inline form-horizontal form-group">
              <label class="control-label" for="background-size">Background Image Size</label>
              <select class="form-control pull-right" id="background-size" onchange="update(); createHistory();">
                <option value="auto">Auto</option>
                <option value="contain">Contain</option>
                <option value="cover" selected>Cover</option>
              </select>
            </div>
            <div class="form-inline form-horizontal form-group">
              <label class="control-label" for="colorpicker-cp2">Background Color</label>
              <div id="cp2" class="input-group colorpicker-component pull-right">
                <input type="text" id="colorpicker-cp2" value="#000000" class="form-control" />
                <span class="input-group-addon"><i></i></span>
              </div>
            </div>
            <hr>
            <div class="form-inline form-horizontal form-group">
              <label class="control-label" for="preview-width">Width</label>
              <input type="number" class="form-control pull-right" id="preview-width"
                onchange="changeSize(); createHistory();" value="400">
            </div>
            <div class="form-inline form-horizontal form-group">
              <label class="control-label" for="preview-height">Height</label>
              <input type="number" class="form-control pull-right" id="preview-height"
                onchange="changeSize(); createHistory();" value="400">
            </div>
            <hr>
            <div class="form-inline form-horizontal form-group">
              <label class="control-label" for="units">Units</label>
              <select class="form-control pull-right" id="units" onchange="update(); createHistory();">
                <option value="px">px</option>
                <option value="%" selected>%</option>
              </select>
            </div>
            <div class="form-inline form-horizontal form-group">
              <label class="control-label" for="fill-rule">Fill Rule</label>
              <select class="form-control pull-right" id="fill-rule" onchange="update(); createHistory();">
                <option value="nonzero" selected>Nonzero (default)</option>
                <option value="evenodd">Even-Odd</option>
              </select>
              <div class="helper-text">Use even-odd if you want to make holes in the middle</div>
            </div>

            <div class="form-group">
              <label for="snap">
                Snap To Grid
              </label>
              <input class="pull-right" id="snap" type="checkbox" checked>
              <div class="helper-text clearfix" id="shift-hint">Hold shift to temporarily disable</div>
            </div>
          </div>
        </div>
      </div>
      <div class="col-md-8">
        <div class="panel panel-default">
          <div class="panel-heading">
            Clip Path
            <div class="pull-right" id="shape-name"></div>
          </div>
          <div class="panel-body">
            <div>
              <div class="form-group" id="preview-container">

                <div id="background-image"></div>

                <div id="grid"></div>
                <div id="selection"></div>
                <div id="shape"></div>
              </div>
            </div>
            <div class="pre-code-snippet">
              <pre class="pre-scrollable language-css" id="output-pre"
                contenteditable><code class="language-css"></code></pre>
              <button class="btn btn-sm btn-default"
                onclick="copyPreToClipboard('#output-pre', 'clip-path-generator')"><i
                  class="glyphicon glyphicon-copy"></i></button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-xs-12">
        <div class="panel panel-default" id="examples">
          <div class="panel-heading">
            Examples
          </div>
          <div class="panel-body">

            <button class="btn btn-default example" data-clip-path="0 0,100 0,50 100" data-units="%">
              <span class="example-preview"></span>
              <span class="example-name">Triangle</span>
            </button>
            <button class="btn btn-default example" data-clip-path="10 10,90 10,90 90,10 90" data-units="%">
              <span class="example-preview"></span>
              <span class="example-name">Square</span>
            </button>
            <button class="btn btn-default example"
              data-clip-path="50 2.447,100 38.774,80.902 97.553,19.098 97.553,00 38.774" data-units="%">
              <span class="example-preview"></span>
              <span class="example-name">Pentagon</span>
            </button>
            <button class="btn btn-default example" data-clip-path="100 50,75 93.301,25 93.301,0 50,25 6.699,75 6.699"
              data-units="%">
              <span class="example-preview"></span>
              <span class="example-name">Hexagon</span>
            </button>
            <button class="btn btn-default example"
              data-clip-path="50 1.253,9.902 20.564,0 63.952,27.748 98.747,72.252 98.747,100 63.952,90.098 20.564"
              data-units="%">
              <span class="example-preview"></span>
              <span class="example-name">Heptagon</span>
            </button>
            <button class="btn btn-default example"
              data-clip-path="70.711 100,100 70.711,100 29.289,70.711 0,29.289 0,0 29.289,0 70.711,29.289 100"
              data-units="%">
              <span class="example-preview"></span>
              <span class="example-name">Octagon</span>
            </button>
            <button class="btn btn-default example" data-clip-path="50 0,90 50,50 100,10 50" data-units="%">
              <span class="example-preview"></span>
              <span class="example-name">Diamond</span>
            </button>
            <button class="btn btn-default example"
              data-clip-path="0 0,100 0,100 100,0 100,10 90,10 10,90 10,90 90,10 90,0 100" data-units="%"
              data-fill-rule="evenodd">
              <span class="example-preview"></span>
              <span class="example-name">Border-Only</span>
            </button>
            <button class="btn btn-default example"
              data-clip-path="50 2.45,61.8 38.77,100 38.77,69.1 61.23,80.9 97.55,50 75.1,19.1 97.55,30.9 61.23,0 38.77,38.2 38.77"
              data-units="%">
              <span class="example-preview"></span>
              <span class="example-name">Star</span>
            </button>
            <button class="btn btn-default example"
              data-clip-path="5.56 5.56,50 0,94.44 5.56,100 50,94.44 94.44,50 100,5.56 94.44,10 90,50 94.44,90 90,94.44 50,90 10,50 5.56,50 34.62,38.24 38.24,34.62 50,38.24 61.76,50 65.38,61.76 61.76,65.38 50,61.76 38.24,50 34.62,50 20.37,72.22 27.78,79.63 50,72.22 72.22,50 79.63,27.78 72.22,20.37 50,27.78 27.78,50 20.37,50 5.56,10 10,5.56 50,10 90,5.56 94.44,0 50"
              data-units="%">
              <span class="example-preview"></span>
              <span class="example-name">Camera</span>
            </button>
            <button class="btn btn-default example"
              data-clip-path="0 0,100 0,100 25,0 25,0 50,100 50,100 75,0 75,0 100,100 100,100 0,75 0,75 100,50 100,50 0,25 0,25 100,0 100"
              data-units="%">
              <span class="example-preview"></span>
              <span class="example-name">Checkerboard</span>
            </button>
            <button class="btn btn-default example"
              data-clip-path="0 0,10 0,10 100,20 100,20 0,30 0,30 100,40 100,40 0,50 0,50 100,60 100,60 0,70 0,70 100,80 100,80 0,90 0,90 100,100 100,100 0,100 10,0 10,0 20,100 20,100 30,0 30,0 40,100 40,100 50,0 50,0 60,100 60,100 70,0 70,0 80,100 80,100 90,0 90,0 100"
              data-units="%">
              <span class="example-preview"></span>
              <span class="example-name">Small Checkerboard</span>
            </button>
            <button class="btn btn-default example"
              data-clip-path="37.5 36,62.5 36,75 11,85.71 36,75 86,62.5 86,62.5 60.07,75 50.57,57.92 50.57,62.5 60.07,62.5 86,37.5 86,37.5 60.07,25 50.57,42.08 50.57,37.5 60.07,37.5 86,25 86,14.29 36,25.9 11"
              data-units="%" data-fill-rule="evenodd">
              <span class="example-preview"></span>
              <span class="example-name">Batman</span>
            </button>
            <button class="btn btn-default example" data-clip-path="0 50,50 0,50 25,100 25,100 75,50 75,50 100"
              data-units="%">
              <span class="example-preview"></span>
              <span class="example-name">Left Arrow</span>
            </button>
            <button class="btn btn-default example" data-clip-path="50 25,50 0,100 50,50 100,50 75,0 75,0 25"
              data-units="%">
              <span class="example-preview"></span>
              <span class="example-name">Right Arrow</span>
            </button>
            <button class="btn btn-default example"
              data-clip-path="5 0,95 0,100 5,100 80,95 85,85 85,85 100,70 85,5 85,0 80,0 5" data-units="%">
              <span class="example-preview"></span>
              <span class="example-name">Speech Bubble</span>
            </button>
            <button class="btn btn-default example"
              data-clip-path="25 25,50 25,75 50,50 75,25 50,37.5 37.5,37.5 62.5,62.5 62.5,62.5 37.5,50 37.5,62.5 50,50 62.5,37.5 50,43.75 43.75,50 43.75,56.25 50,50 56.25,43.75 50,46.88 46.88,53.13 46.88,53.13 53.13,46.88 53.13,46.88 46.88,50 43.75,56.25 43.75,56.25 56.25,43.75 56.25,43.75 43.75,50 37.5,37.5 37.5,50 25,75 25,75 75,25 75,0 50,50 0,100 50,50 100,25 75"
              data-units="%" data-fill-rule="evenodd">
              <span class="example-preview"></span>
              <span class="example-name">Concentric Squares</span>
            </button>

          </div>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-xs-12">
        <h2>FAQ</h2>

        <h3>What is the browser compatibility like?</h3>
        <p>With the exception of a handful of older browsers, <a href="https://caniuse.com/css-clip-path">support is
            pretty good</a> when using the <code>polygon()</code> function.</p>
        <h3>How does the grid work?</h3>
        <p>When you have <a href="#snap">Snap To Grid</a> enabled, it will automatically generate some useful lines,
          circles and points for creating right angles, equal lengths, triangles and align the points into lots of
          different useful places.</p>
        <h3>Can I edit an existing <code>clip-path</code>?</h3>
        <p>Sure! Just paste your <code>clip-path</code> code into the output box and we'll do our best to parse it. You
          can also edit a generated <code>clip-path</code> to see how some tweaks would look.</p>
        <h3>What controls are there?</h3>
        <ul>
          <li>Drag from the middle of a line to add a new point</li>
          <li>Hold shift while dragging to temporarily disable the grid</li>
          <li>Hold shift while clicking to select two corners</li>
          <li>Drag a box around multiple corners to select lots</li>
          <li>Click on an edge to select two corners</li>
          <li>Drag the whole shape</li>
          <li>Undo (Ctrl+Z or ⌘+Z)</li>
          <li>Redo (Ctrl+Y or ⌘+⇧+Z)</li>
          <li>New (Ctrl+N or ⌘+N)</li>
          <li>Save (Ctrl+S or ⌘+S)</li>
          <li>Copy The Snippet (Ctrl+C or ⌘+C)</li>
          <li>Share your creation using a permanent link</li>
        </ul>

      </div>
    </div>
  </div>

  <script src="./static/js/scripts.3fc4a5b0e1fe.js"></script>
  <script src="./static/js/glmatrix.0286845c8401.js"></script>
  <script src="./static/js/tools.673b972745ae.js"></script>
  <script>
    Array.prototype.rotateLeft = function (n) {
      this.unshift.apply(this, this.splice(n, this.length));
      return this;
    }

    const MAX_HISTORY = 100;

    let applyingHistory = false;
    let history = [];
    let historyPos = -1;

    function createTimeout (timeoutHandler, delay) {
      const timeoutId = timeoutHandler ? setTimeout(timeoutHandler, delay) : -1;
      return {
        clear: function () {
          clearTimeout(timeoutId);
          timeoutHandler = null;
        },
        trigger: function () {
          clearTimeout(timeoutId);
          if (timeoutHandler) {
            const result = timeoutHandler();
            timeoutHandler = null;
            return result;
          }
        },
        isWaiting: function () {
          return !!timeoutHandler;
        }
      };
    }

    let historyTimeout = createTimeout();
    function maybeCreateHistory () {
      if (!applyingHistory) {
        historyTimeout.clear();
        historyTimeout = createTimeout(createHistory, 500);
      }
    }

    function createHistory () {
      if (!applyingHistory) {
        historyTimeout.clear();
        const historyItem = createHistoryItem();

        if (history.length == 0) {
          history.push(historyItem);
          historyPos = 0;
        } else {
          if (historyPos > history.length - 1) {
            historyPos = history.length - 1;
          }
          if (!historyMatches(history[historyPos], historyItem)) {
            history = history.slice(0, historyPos + 1);
            history.push(historyItem);
            while (history.length > MAX_HISTORY) {
              history.shift();
            }
            historyPos = history.length - 1;
          }
        }

        if (window.afterHistory) {
          afterHistory();
        }
      }
    }


    function applyHistory () {
      if (historyPos > -1 && historyPos < history.length) {
        const historyData = history[historyPos];
        applyingHistory = true;

        const historyItem = history[historyPos];
        applyHistoryItem(historyItem);

        applyingHistory = false;
      }
    }

    function updateCurrentHistory (fn) {
      if (historyPos > -1 && historyPos < history.length) {
        fn(history[historyPos]);
      }
    }

    function clearHistory () {
      if (history.length > 1) {
        history = [history[history.length - 1]];
      }
      historyPos = 0;
      updateHistoryButtons();
    }

    function undo () {
      historyTimeout.trigger();
      if (historyPos > 0) {
        historyPos--;
        applyHistory();
        updateHistoryButtons();
      }
    }

    function redo () {
      historyTimeout.clear();
      if (historyPos < history.length - 1) {
        historyPos++;
        applyHistory();
        updateHistoryButtons();
      }
    }

    function download () {
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(outputPre.innerText));
      element.setAttribute('download', 'clip-path.txt');

      element.style.display = 'none';
      document.body.appendChild(element);

      element.click();

      document.body.removeChild(element);
    }

    document.addEventListener('keydown', function (e) {
      const evt = window.event ? event : e;
      if (evt.keyCode === 90 && (evt.ctrlKey || evt.metaKey)) {
        if (evt.shiftKey) {
          evt.preventDefault();
          redo();
        } else {
          evt.preventDefault();
          undo();
        }
      } else if (evt.keyCode === 89 && (evt.ctrlKey || evt.metaKey)) {
        evt.preventDefault();
        redo();
      } else if (evt.keyCode === 78 && (evt.ctrlKey || evt.metaKey)) {
        evt.preventDefault();
        initDefault();
      } else if (evt.keyCode === 79 && (evt.ctrlKey || evt.metaKey)) {
        evt.preventDefault();
      } else if (evt.keyCode === 83 && (evt.ctrlKey || evt.metaKey)) {
        evt.preventDefault();
        download();
      } else if (evt.keyCode === 67 && (evt.ctrlKey || evt.metaKey)) {
        if (evt.target.type !== 'text') {
          evt.preventDefault();
          copyPreToClipboard('#output-pre', 'clip-path-code');
        }
      }
    });

    function removeSortedDuplicates (array) {
      let groupStart = 0;
      for (var i = 1; i < array.length; i++) {
        if (array[i - 1] !== array[i]) {
          if (i - groupStart > 1) {
            array.splice(groupStart + 1, i - groupStart - 1);
          }
          groupStart = i;
        }
      }

      array.splice(groupStart + 1, array.length);
      return array;
    }

    function removeDuplicates (array) {
      for (var i = 0; i < array.length; i++) {
        for (var j = i + 1; j < array.length; j++) {
          if (array[i] === array[j]) {
            array.splice(j--, 1);
          }
        }
      }

      return array;
    }

    const { mat2, mat2d, vec2 } = glMatrix;

    const shape = document.getElementById('shape');
    const dragHandles = [];
    const precisionCheckbox = document.getElementById('precision');
    const shapeName = document.getElementById('shape-name');
    const previewContainer = document.getElementById('preview-container');
    const outputPre = document.getElementById('output-pre');
    const grid = document.getElementById('grid');
    const snap = document.getElementById('snap');
    const selection = document.getElementById('selection');
    const link = document.getElementById('sharable-link');
    const shareTwitter = document.getElementById('share-twitter');
    const shareFacebook = document.getElementById('share-facebook');


    const units = document.getElementById('units');
    const backgroundInput = document.getElementById('background');
    const backgroundSize = document.getElementById('background-size');
    const fillRule = document.getElementById('fill-rule');
    const backgroundImage = document.getElementById('background-image');
    const previewWidth = document.getElementById('preview-width');
    const previewHeight = document.getElementById('preview-height');


    const maxSnapPoints = 500;
    const snapDistance = 10;
    let pointsIndex;
    let dragging = null;
    let notDragging = null;
    let startX = null;
    let startY = null;
    let snapLines = [];
    let snapPoints = [];
    let cachedWidth = 0;
    let cachedHeight = 0;
    let cachedWindowWidth = 0;
    let startSelected = [];
    let oldText = '';
    let parsing = false;


    let createdHandle = null;

    function round2dp (number) {
      return Math.round((number + Number.EPSILON) * 100) / 100;
    }

    function loadFile () {
      var file = backgroundInput.files[0];
      backgroundInput.value = null;
      if (!file) {
        return;
      }
      var reader = new FileReader();
      reader.onload = function (e) {

        var image = new Image();
        image.onload = function (imageEvent) {
          var canvas = document.createElement("canvas");

          var maxWidth = previewContainer.parentElement.clientWidth;
          var width = Math.min(image.width, maxWidth);
          var height = width * (image.height / image.width);

          previewWidth.value = Math.round(width);
          previewHeight.value = Math.round(height);
          changeSize();

          var widthRatio = cachedWidth / image.width;
          var heightRatio = cachedHeight / image.height;

          if (image.width * widthRatio > 500) {
            widthRatio = 500 / image.width;
          }

          if (image.height * heightRatio > 500) {
            heightRatio = 500 / image.height;
          }

          if (widthRatio > heightRatio) {
            canvas.width = image.width * widthRatio;
            canvas.height = image.height * widthRatio;
          } else {
            canvas.width = image.width * heightRatio;
            canvas.height = image.height * heightRatio;
          }

          var ctx = canvas.getContext("2d");

          ctx.drawImage(image, 0, 0, canvas.width, canvas.height);

          shape.style.background = 'url(' + canvas.toDataURL() + ')';
          backgroundImage.style.background = shape.style.background;

          update();
          createHistory();
        }
        image.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    function changeSize () {
      cachedWindowWidth = null;
      var oldWidth = cachedWidth;
      var oldHeight = cachedHeight;
      var newWidth = previewWidth.value;
      var newHeight = previewHeight.value;
      previewContainer.style.width = (parseInt(newWidth) + 2) + 'px';
      previewContainer.style.height = (parseInt(newHeight) + 2) + 'px';
      previewContainer.style.minWidth = (parseInt(newWidth) + 2) + 'px';
      previewContainer.style.minHeight = (parseInt(newHeight) + 2) + 'px';
      updateCachedSize();

      for (var i = 0; i < dragHandles.length; i++) {
        dragHandles[i].dataset.x = round3dp(parseFloat(dragHandles[i].dataset.x) * newWidth / oldWidth);
        dragHandles[i].dataset.y = round3dp(parseFloat(dragHandles[i].dataset.y) * newHeight / oldHeight);
        dragHandles[i].style.transform = "translate(" + dragHandles[i].dataset.x + "px, " + dragHandles[i].dataset.y + "px)";
      }

      update();
    }

    function circleFromPoints (center, edge) {
      return [center, vec2.distance(center, edge)];
    }

    function hsl2hex (h, s, l) {
      // Must be fractions of 1
      s = s / 100;
      l = l / 100;

      let c = (1 - Math.abs(2 * l - 1)) * s,
        x = c * (1 - Math.abs((h / 60) % 2 - 1)),
        m = l - c / 2,
        r = 0,
        g = 0,
        b = 0;

      if (0 <= h && h < 60) {
        r = c; g = x; b = 0;
      } else if (60 <= h && h < 120) {
        r = x; g = c; b = 0;
      } else if (120 <= h && h < 180) {
        r = 0; g = c; b = x;
      } else if (180 <= h && h < 240) {
        r = 0; g = x; b = c;
      } else if (240 <= h && h < 300) {
        r = x; g = 0; b = c;
      } else if (300 <= h && h < 360) {
        r = c; g = 0; b = x;
      }
      r = Math.round((r + m) * 255);
      g = Math.round((g + m) * 255);
      b = Math.round((b + m) * 255);

      return '#' + r.toString(16).padStart(2, '0') + g.toString(16).padStart(2, '0') + b.toString(16).padStart(2, '0');
    }

    function distanceFromPointToLine (point, line) {
      let x = point[0];
      let y = point[1];
      let x1 = line[0][0];
      let y1 = line[0][1];
      let x2 = line[1][0];
      let y2 = line[1][1];

      let A = x - x1;
      let B = y - y1;
      let C = x2 - x1;
      let D = y2 - y1;

      let dot = A * C + B * D;
      let len_sq = C * C + D * D;
      let param = -1;

      // Check for 0 length line
      if (len_sq != 0) {
        param = dot / len_sq;
      }

      let xx, yy;

      if (param < 0) {
        xx = x1;
        yy = y1;
      } else if (param > 1) {
        xx = x2;
        yy = y2;
      } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
      }

      var dx = x - xx;
      var dy = y - yy;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function applyExample (example) {
      clearHandles();
      const path = example.dataset.clipPath.split(',').map(function (a) {
        const xy = a.split(' ');
        return [parseFloat(xy[0]), parseFloat(xy[1])];
      });

      const width = previewContainer.clientWidth;
      const height = previewContainer.clientHeight;
      path.forEach(function (p) {
        createHandle(p[0] * width / 100, p[1] * height / 100);
      });

      units.value = example.dataset.units;
      fillRule.value = example.dataset.fillRule || 'nonzero';
      $('#cp2').colorpicker('setValue', example.dataset.background);
      update();
      createHistory();
      const name = example.querySelector('.example-name');
      track('load-example', 'clip-path-' + name.innerText.replace(/ /g, '-'));
    }

    let exampleHue = 0;
    function setExampleStyle (example) {
      const path = example.dataset.clipPath.split(',').map(function (a) {
        const xy = a.split(' ');
        return xy[0] + example.dataset.units + ' ' + xy[1] + example.dataset.units;
      });
      const fillRule = example.dataset.fillRule ? example.dataset.fillRule + ', ' : '';

      const preview = example.querySelector('.example-preview');
      preview.style.clipPath = 'polygon(' + fillRule + path + ')';

      const background = hsl2hex(exampleHue, 80, 60);
      example.dataset.background = background;
      preview.style.background = background;
      exampleHue = (exampleHue + 180 + 41) % 360;
    }

    function handleColor (index) {
      return hsl2hex((index * 221) % 360, 80, 60)
    }

    function setHandleStyles () {
      for (let i = 0; i < dragHandles.length; i++) {
        const color = handleColor(i);
        dragHandles[i].style.background = color;
        if (i < textHighlights.length) {
          textHighlights[i].style.color = color;
          textHighlights[i].style.borderBottomColor = color;
        }
      }
    }


    function round3dp (number) {
      return Math.round((number + Number.EPSILON) * 1000) / 1000;
    }

    function deleteHandle (handle) {
      handle.parentElement.removeChild(handle);
      const index = dragHandles.indexOf(handle);
      if (index > -1) {
        dragHandles.splice(index, 1);
      }


      setHandleStyles();

    }

    function clearHandles () {
      dragHandles.splice(0, dragHandles.length)
      previewContainer.querySelectorAll('.drag-handle').forEach(function (handle) {
        previewContainer.removeChild(handle);
      });
    }

    function handleEnter (handleIndex) {

      if (handleIndex >= 0 && handleIndex < textHighlights.length && !textHighlights[handleIndex].classList.contains('hovered')) {
        textHighlights[handleIndex].classList.add('hovered');
      }

    }

    function handleLeave (handleIndex) {

      if (handleIndex >= 0 && handleIndex < textHighlights.length && textHighlights[handleIndex].classList.contains('hovered')) {
        textHighlights[handleIndex].classList.remove('hovered');
      }

    }

    function createHandle (x, y, index) {
      const handle = document.createElement('div');
      handle.classList.add('drag-handle');
      handle.dataset.startx = x;
      handle.dataset.x = x;
      handle.dataset.starty = y;
      handle.dataset.y = y;


      const deleteIcon = document.createElement('span');
      deleteIcon.classList.add('glyphicon', 'glyphicon-trash');

      const deleteButton = document.createElement('div');
      deleteButton.classList.add('delete-button');
      deleteButton.addEventListener('click', function (e) {
        deleteHandle(handle);
        update();
        e.cancelBubble = true;
      });

      deleteButton.appendChild(deleteIcon);
      handle.appendChild(deleteButton);
      handle.tabIndex = 0;


      handle.style.transform = "translate(" + handle.dataset.x + "px, " + handle.dataset.y + "px)";
      handle.addEventListener("mousedown", mouseDown, { passive: false });
      handle.addEventListener("touchstart", touchDown, { passive: false });
      handle.addEventListener("mouseenter", function () {
        const handleIndex = dragHandles.indexOf(handle);
        handleEnter(handleIndex);
      });
      handle.addEventListener("mouseleave", function () {
        const handleIndex = dragHandles.indexOf(handle);
        handleLeave(handleIndex);
      });

      if (index === undefined || index >= dragHandles.length) {
        previewContainer.appendChild(handle);
        dragHandles.push(handle);
      } else {
        previewContainer.insertBefore(handle, dragHandles[index + 1]);
        dragHandles.splice(index, 0, handle);
      }


      setHandleStyles();

      return handle;
    }

    function mouseDown (e) {
      if (e.button == 0) {
        if (e.target.classList.contains('drag-handle') || e.target === shape || e.target === previewContainer) {
          down(e.pageX, e.pageY, e.target, e.shiftKey, e.offsetX, e.offsetY);
          e.preventDefault();
          e.cancelBubble = true;
        }
      }
    }

    function touchDown (e) {
      if (e.touches[0].target.classList.contains('drag-handle') || e.touches[0].target === shape || e.touches[0].target === previewContainer) {
        const clientRect = e.touches[0].target.getBoundingClientRect();
        const offsetX = e.touches[0].clientX - clientRect.x;
        const offsetY = e.touches[0].clientY - clientRect.y;
        down(e.touches[0].pageX, e.touches[0].pageY, e.touches[0].target, e.shiftKey, offsetX, offsetY);
        e.preventDefault();
        e.cancelBubble = true;
      }
    }


    function setupGrid (focusPoint, notDragging) {
      if (notDragging.length === 0) {
        snapLines = [];
        snapPoints = [];
        snapCircles = [];
        return;
      }
      let otherPoints = notDragging
        .map(function (handle) { return vec2.fromValues(parseFloat(handle.dataset.x), parseFloat(handle.dataset.y)); });

      const extraSnapLines = otherPoints.flatMap(otherPoint => [
        { line: getHorizontalLine(otherPoint), names: ['Horizontal'], highlights: [{ point: otherPoint }], priority: -1 },
        { line: getVerticalLine(otherPoint), names: ['Vertical'], highlights: [{ point: otherPoint }], priority: -1 }
      ]);

      if (otherPoints.length === 1) {
        snapLines = extraSnapLines;
        snapPoints = [];
        snapCircles = [];
        return;
      }

      let before = (otherPoints.length * 2 - 1) % otherPoints.length;
      let before2 = (otherPoints.length * 2 - 2) % otherPoints.length;
      let after = 0;
      let after2 = 1 % otherPoints.length;
      const rightAngleCircle = getRightAngleCircle(otherPoints[before], otherPoints[after]);
      const beforeHighlight = { line: [otherPoints[before], focusPoint], infinite: false, dynamic: true };
      const afterHighlight = { line: [otherPoints[after], focusPoint], infinite: false, dynamic: true };
      const beforeAfterHighlight = { line: [otherPoints[before], otherPoints[after]], infinite: false };

      const isoscelesLine = {
        line: getPerpendicularLine(otherPoints[before], otherPoints[after], 0.5), names: ["Equal Length"], infinite: true, highlights: [
          beforeHighlight, afterHighlight
        ]
      };
      const rightAngle1 = {
        line: getPerpendicularLine(otherPoints[before2], otherPoints[before], 1), names: ["Right Angle"], infinite: true, highlights: [
          { rightAngle: [otherPoints[before2], otherPoints[before], focusPoint] }
        ]
      };
      const rightAngle2 = {
        line: getPerpendicularLine(otherPoints[after], otherPoints[after2], 0), names: ["Right Angle"], infinite: true, highlights: [
          { rightAngle: [focusPoint, otherPoints[after], otherPoints[after2]] }
        ]
      };

      snapLines = [
        isoscelesLine,
        rightAngle1,
        rightAngle2
      ];

      snapPoints = [];

      for (let i = 0; i < otherPoints.length - 1; i++) {
        for (let j = i + 1; j < otherPoints.length; j++) {
          const line = {
            line: [otherPoints[i], otherPoints[j]],
            infinite: true,
            highlights: [{ point: otherPoints[i] }, { point: otherPoints[j] }],
            names: ['Collinear'],
            priority: -2,
          };
          extraSnapLines.push(line);

          const a = otherPoints[i];
          const b = otherPoints[j];
          const c = [
            a[0] + (b[0] - a[0]) / 2,
            a[1] + (b[1] - a[1]) / 2
          ];
          const highlights = [
            line,
            { point: c }
          ];
          const point = { point: c, names: ['Center'], highlights: highlights };
          line.references = [point];
          snapPoints.push(point);
        }
      }

      // Don't add the horizontal or vertical lines if they already exist
      for (let i = 0; i < extraSnapLines.length; i++) {
        let found = false;
        for (let j = 0; j < snapLines.length; j++) {
          if (snapLines[j].infinite && extraSnapLines[i].infinite &&
            collinear(snapLines[j].line[0], snapLines[j].line[1], extraSnapLines[i].line[0]) &&
            collinear(snapLines[j].line[0], snapLines[j].line[1], extraSnapLines[i].line[1])) {
            found = true;
            snapLines[j].highlights = removeDuplicates((snapLines[j].highlights || []).concat(extraSnapLines[i].highlights || []));
            const names = (snapLines[j].names || []).concat(extraSnapLines[i].names || []);
            names.sort();
            snapLines[j].names = removeSortedDuplicates(names);
            if (extraSnapLines[i].references) {
              for (let k = 0; k < extraSnapLines[i].references.length; k++) {
                const referenceIndex = extraSnapLines[i].references[k].highlights.indexOf(extraSnapLines[i]);
                extraSnapLines[i].references[k].highlights[referenceIndex] = snapLines[j];
              }
            }
          }
        }
        if (!found) {
          snapLines.push(extraSnapLines[i]);
        }
      }

      const rightAngle = {
        circle: rightAngleCircle, names: ["Right Angle"], highlights: [
          { rightAngle: [otherPoints[before], focusPoint, otherPoints[after]] }
        ]
      };
      const equalLengthBefore =
      {
        circle: circleFromPoints(otherPoints[before], otherPoints[before2]), names: ["Equal Length"], highlights: [
          { line: [otherPoints[before], otherPoints[before2]], infinite: false },
          beforeHighlight,
        ]
      };
      const equalLengthAfter =
      {
        circle: circleFromPoints(otherPoints[after], otherPoints[after2]), names: ["Equal Length"], highlights: [
          { line: [otherPoints[after], otherPoints[after2]], infinite: false },
          afterHighlight,
        ]
      };
      snapCircles = [
        rightAngle,
        equalLengthBefore,
        equalLengthAfter
      ];

      snapPoints.push(
        {
          point: rotatePoint(otherPoints[after], Math.PI / 3, otherPoints[before]), names: ["Equilateral"], highlights: [
            isoscelesLine, beforeHighlight, afterHighlight, beforeAfterHighlight
          ]
        }, //Equilateral, cw
        {
          point: rotatePoint(otherPoints[after], -Math.PI / 3, otherPoints[before]), names: ["Equilateral"], highlights: [
            isoscelesLine, beforeHighlight, afterHighlight, beforeAfterHighlight
          ]
        }, //Equilateral, ccw
      );
    }


    function tidyGrid () {
      for (let i = 0; i < snapPoints.length - 1; i++) {
        for (let j = i + 1, n = snapPoints.length; j < n; j++) {
          const si = snapPoints[i];
          const sj = snapPoints[j];
          const xDiff = si.point[0] - sj.point[0];
          const yDiff = si.point[1] - sj.point[1];
          if (si !== sj &&
            xDiff > -0.2 && xDiff < 0.2 &&
            yDiff > -0.2 && yDiff < 0.2) {
            if (!si.noMergeNames) {
              if (sj.noMergeNames) {
                si.names = sj.names;
              } else {
                si.names = (si.names || []).concat(sj.names || []);
              }
            }
            si.highlights = (si.highlights || []).concat(sj.highlights || []);
            snapPoints.splice(j, 1);
            j--;
            n--;
          }
        }
      }

      snapPoints.sort(function (a, b) {
        return (a.priority || 0) - (b.priority || 0);
      });

      if (snapPoints.length >= maxSnapPoints) {
        let groupStart = 0;
        let lastPriority = 0;
        for (let i = 0; i < maxSnapPoints; i++) {
          const priority = snapPoints[i].priority;
          if (priority < lastPriority) {
            groupStart = i;
          }
        }
        if (groupStart == 0) {
          groupStart = maxSnapPoints;
        }
        snapPoints = snapPoints.slice(0, groupStart);
      }

      for (let i = 0; i < snapLines.length; i++) {
        snapLines[i].line[0][0] = round3dp(snapLines[i].line[0][0]);
        snapLines[i].line[0][1] = round3dp(snapLines[i].line[0][1]);
        snapLines[i].line[1][0] = round3dp(snapLines[i].line[1][0]);
        snapLines[i].line[1][1] = round3dp(snapLines[i].line[1][1]);
      }
      for (let i = 0; i < snapPoints.length; i++) {
        snapPoints[i].point[0] = round3dp(snapPoints[i].point[0]);
        snapPoints[i].point[1] = round3dp(snapPoints[i].point[1]);
      }
      for (let i = 0; i < snapCircles.length; i++) {
        snapCircles[i].circle[0][0] = round3dp(snapCircles[i].circle[0][0]);
        snapCircles[i].circle[0][1] = round3dp(snapCircles[i].circle[0][1]);
      }
    }

    function maybeAddSnapPoints (newSnapPoints, names, highlights, priority) {
      for (let i = 0; i < newSnapPoints.length; i++) {
        if (newSnapPoints[i][0] < 0 || newSnapPoints[i][0] > cachedWidth ||
          newSnapPoints[i][1] < 0 || newSnapPoints[i][1] > cachedHeight) {
          continue;
        }
        let found = false;

        const maybeMatches = pointsIndex.query(new QT.Box(newSnapPoints[i][0] - 1, newSnapPoints[i][1] - 1, newSnapPoints[i][0] + 1, newSnapPoints[i][1] + 1));
        for (let j = 0; j < maybeMatches.length && !found; j++) {
          if (Math.abs(newSnapPoints[i][0] - maybeMatches[j].point[0]) <= 0.01 &&
            Math.abs(newSnapPoints[i][1] - maybeMatches[j].point[1]) <= 0.01) {
            if (names && names.length > 0) {
              if (!maybeMatches[j].names) {
                maybeMatches[j].names = [];
              }
              maybeMatches[j].names = maybeMatches[j].names.concat(names);
              maybeMatches[j].names.sort();
              removeSortedDuplicates(maybeMatches[j].names);
            }
            maybeMatches[j].highlights = removeDuplicates((maybeMatches[j].highlights || []).concat(highlights));
            maybeMatches[j].priority = Math.max(maybeMatches[j].priority || 0, priority);
            found = true;
          }
        }
        if (!found) {
          const point = {
            point: newSnapPoints[i],
            names: names,
            highlights: highlights,
            x: newSnapPoints[i][0],
            y: newSnapPoints[i][1]
          };
          pointsIndex.insert(point);
          snapPoints.push(point);
        }
      }
    }

    function getPointNames (snap1, snap2) {
      if (snap1.names && !snap2.names) {
        return snap1.names;
      } else if (!snap1.names && snap2.names) {
        return snap2.names;
      } else if (snap1.names && snap2.names) {
        const result = snap1.names.concat(snap2.names).sort();
        return removeSortedDuplicates(result);
      }
      return null;
    }

    function addExtraSnapPoints () {
      for (let i = 0; i < snapPoints.length; i++) {
        const snapPoint = snapPoints[i];
        snapPoint.x = snapPoint.point[0];
        snapPoint.y = snapPoint.point[1];
        pointsIndex.insert(snapPoint);
      }

      for (let i = 0; i < snapLines.length - 1 && snapPoints.length < maxSnapPoints; i++) {
        for (let j = i + 1; j < snapLines.length && snapPoints.length < maxSnapPoints; j++) {
          const intersections = lineLineIntersection(snapLines[i].line, snapLines[j].line, snapLines[i].infinite, snapLines[j].infinite);
          const names = getPointNames(snapLines[i], snapLines[j]);
          const priority = Math.min(snapLines[i].priority || 0, snapLines[j].priority || 0);
          maybeAddSnapPoints(intersections, names, [snapLines[i], snapLines[j]], priority);
        }
      }

      for (let i = 0; i < snapCircles.length - 1 && snapPoints.length < maxSnapPoints; i++) {
        for (let j = i + 1; j < snapCircles.length && snapPoints.length < maxSnapPoints; j++) {
          const intersections = circleCircleIntersection(snapCircles[i].circle, snapCircles[j].circle);
          const names = getPointNames(snapCircles[i], snapCircles[j]);
          const priority = Math.min(snapCircles[i].priority || 0, snapCircles[j].priority || 0);
          maybeAddSnapPoints(intersections, names, [snapCircles[i], snapCircles[j]], priority);
        }
      }

      for (let i = 0; i < snapLines.length && snapPoints.length < maxSnapPoints; i++) {
        for (let j = 0; j < snapCircles.length && snapPoints.length < maxSnapPoints; j++) {
          const intersections = lineCircleIntersection(snapLines[i].line, snapCircles[j].circle, snapLines[i].infinite);
          const names = getPointNames(snapLines[i], snapCircles[j]);
          const priority = Math.min(snapLines[i].priority || 0, snapCircles[j].priority || 0);
          maybeAddSnapPoints(intersections, names, [snapLines[i], snapCircles[j]], priority);
        }
      }
    }

    function selectionChanged () {

      if (outputTimeout.isWaiting) {
        displayOutput();
      }
      for (let i = 0; i < dragHandles.length && i < textHighlights.length; i++) {
        if (dragHandles[i].classList.contains('selected')) {
          if (!textHighlights[i].classList.contains('selected')) {
            textHighlights[i].classList.add('selected');
          }
        } else {
          if (textHighlights[i].classList.contains('selected')) {
            textHighlights[i].classList.remove('selected');
          }
        }
      }

    }

    function down (pageX, pageY, target, shift, offsetX, offsetY) {
      let selected = [].slice.call(previewContainer.querySelectorAll('.drag-handle.selected'));
      const focused = previewContainer.querySelector('.drag-handle:focus');


      if (target === shape || target === previewContainer) {
        const rect = previewContainer.getBoundingClientRect();
        const bodyRect = document.body.getBoundingClientRect();
        const rebasedX = pageX - Math.round(rect.left - bodyRect.left);
        const rebasedY = pageY - Math.round(rect.top - bodyRect.top);
        const point = [rebasedX, rebasedY];

        if (dragHandles.length < 3) {
          target = createHandle(rebasedX, rebasedY);
        } else {
          let closestLine = null;
          let closestDistance = null;
          for (let i = 0; i < dragHandles.length && dragHandles.length > 1; i++) {
            const next = (i + 1) % dragHandles.length;

            const line = [
              [
                parseFloat(dragHandles[i].dataset.x),
                parseFloat(dragHandles[i].dataset.y)
              ],
              [
                parseFloat(dragHandles[next].dataset.x),
                parseFloat(dragHandles[next].dataset.y)
              ]
            ];

            const d = distanceFromPointToLine(point, line);
            if (d < snapDistance && (!closestLine || d < closestDistance)) {
              closestLine = i + 1;
              closestDistance = d;
            }
          }

          if (closestLine !== null) {
            target = createHandle(rebasedX, rebasedY, closestLine);
            target.style.display = 'none';
            createdHandle = {
              startX: rebasedX,
              startY: rebasedY,
              handle: target
            };
          }
        }
      }


      if (target.classList.contains('drag-handle')) {
        target.focus();
        target.classList.add('selected');
      }

      if (target === previewContainer) {
        target = selection;
      } else {
        previewContainer.classList.add('mouse-down');
      }

      if (target === shape) {
        dragging = shape;
      } else {
        const index = selected.indexOf(target);
        if (index !== -1) {
          if (shift && selected.length > 1) {
            target.classList.remove('selected');
            target.blur();
            selectionChanged();
            return;
          }
          dragging = selected.rotateLeft(selected.indexOf(target));
        } else {
          if (!shift) {
            selected.forEach(function (e) {
              e.classList.remove('selected');
              e.blur();
            });
            selected = [];
          }
          if (target === selection) {
            dragging = selection;
            startSelected = selected;
          } else {
            selected.push(target);
            dragging = selected;
          }
        }

        if (dragging !== selection) {
          const draggingIndex = dragHandles.indexOf(dragging[0]);
          notDragging = dragHandles.concat().rotateLeft(draggingIndex).filter(function (e) { return !dragging.includes(e); });
        }
      }

      startX = pageX;
      startY = pageY;

      for (let i = 0; i < dragHandles.length; i++) {
        dragHandles[i].dataset.startx = dragHandles[i].dataset.x;
        dragHandles[i].dataset.starty = dragHandles[i].dataset.y;
      }

      selectionChanged();

      if (dragging === selection) {
        selection.dataset.startx = offsetX;
        selection.dataset.starty = offsetY;
        selection.style.display = 'block';
        selection.style.width = '0px';
        selection.style.height = '0px';
        selection.style.transform = 'translate(' + selection.dataset.startx + 'px, ' + selection.dataset.starty + 'px)';
        return;
      }

      if (dragging === shape) {
        dragHandles.forEach(function (e) {
          e.classList.add('dragging');
        });
      } else {
        dragging.forEach(function (e) {
          e.classList.add('dragging');
        });

        pointsIndex.clear();
        setupGrid(dragging[0], notDragging);
        addExtraSnapPoints();
        tidyGrid();
        displayGrid();
      }

      if (snap.checked && !shift && dragging !== shape) {
        grid.style.display = "block";
      } else {
        shapeName.innerText = "";
        grid.style.display = "none";
      }
    }

    function mouseMove (e) {
      move(e.pageX, e.pageY, e.shiftKey);
    }

    function touchMove (e) {
      move(e.touches[0].pageX, e.touches[0].pageY, e.shiftKey);
    }

    function move (pageX, pageY, shift) {
      if (dragging) {
        if (dragging === selection) {
          let startPoint = [
            parseFloat(selection.dataset.startx),
            parseFloat(selection.dataset.starty)
          ];
          let endPoint = [
            startPoint[0] - startX + pageX,
            startPoint[1] - startY + pageY
          ];
          const smallestX = Math.min(startPoint[0], endPoint[0]);
          const largestX = Math.max(startPoint[0], endPoint[0]);
          const smallestY = Math.min(startPoint[1], endPoint[1]);
          const largestY = Math.max(startPoint[1], endPoint[1]);
          const width = largestX - smallestX;
          const height = largestY - smallestY;
          selection.style.width = width + 'px';
          selection.style.height = height + 'px';
          selection.style.transform = 'translate(' + smallestX + 'px, ' + smallestY + 'px)';
          for (let i = 0; i < dragHandles.length; i++) {
            const x = parseFloat(dragHandles[i].dataset.x);
            const y = parseFloat(dragHandles[i].dataset.y);

            if (x >= smallestX && x <= largestX && y >= smallestY && y <= largestY) {
              dragHandles[i].classList.add('selected');
            } else if (startSelected.indexOf(dragHandles[i]) === -1) {
              dragHandles[i].classList.remove('selected');
            }
          }
          selectionChanged();
        } else {
          const currentDragHandles = dragging === shape ? dragHandles : dragging;
          let xDiff = pageX - startX;
          let yDiff = pageY - startY;
          let realXDiff = xDiff;
          let realYDiff = yDiff;

          let point0 = [
            parseFloat(currentDragHandles[0].dataset.startx) + realXDiff,
            parseFloat(currentDragHandles[0].dataset.starty) + realYDiff
          ];
          let maybeSnapPoint = point0.concat();
          if (snap.checked && !shift && dragging !== shape) {
            maybeSnapPoint = maybeSnap(maybeSnapPoint);
            grid.style.display = "block";
          } else {
            shapeName.innerText = "";
            grid.style.display = "none";
          }
          let maybeSnapDiff = [
            realXDiff + maybeSnapPoint[0] - point0[0],
            realYDiff + maybeSnapPoint[1] - point0[1]
          ];

          for (let i = 0; i < currentDragHandles.length; i++) {
            let p = [
              parseFloat(currentDragHandles[i].dataset.startx),
              parseFloat(currentDragHandles[i].dataset.starty)
            ]
            let newPoint = [
              p[0] + realXDiff,
              p[1] + realYDiff
            ];

            if (newPoint[0] < 0) {
              realXDiff -= newPoint[0];
            }
            if (newPoint[0] > cachedWidth) {
              realXDiff -= newPoint[0] - cachedWidth;
            }
            if (newPoint[1] < 0) {
              realYDiff -= newPoint[1];
            }
            if (newPoint[1] > cachedHeight) {
              realYDiff -= newPoint[1] - cachedHeight;
            }

            if (maybeSnapDiff) {
              let newSnapPoint = [
                p[0] + maybeSnapDiff[0],
                p[1] + maybeSnapDiff[1]
              ];

              if (newSnapPoint[0] < 0 || newSnapPoint[0] > cachedWidth || newSnapPoint[1] < 0 || newSnapPoint[1] > cachedHeight) {
                maybeSnapDiff = null;
              }
            }
          }

          if (maybeSnapDiff) {
            realXDiff = maybeSnapDiff[0];
            realYDiff = maybeSnapDiff[1];
          } else {
            shapeName.innerText = "";
            removeHighlights();
          }

          for (let i = 0; i < currentDragHandles.length; i++) {
            let newRealPoint = [
              round3dp(parseFloat(currentDragHandles[i].dataset.startx) + realXDiff),
              round3dp(parseFloat(currentDragHandles[i].dataset.starty) + realYDiff)
            ];
            currentDragHandles[i].dataset.x = newRealPoint[0];
            currentDragHandles[i].dataset.y = newRealPoint[1];
            currentDragHandles[i].style.transform = "translate(" + newRealPoint[0] + "px, " + newRealPoint[1] + "px)";
          }

          lastX = pageX;
          lastY = pageY;


          if (createdHandle && dragging[0] === createdHandle.handle) {
            const newX = parseFloat(createdHandle.handle.dataset.x);
            const newY = parseFloat(createdHandle.handle.dataset.y);
            if (Math.abs(createdHandle.startX - newX) > 5 || Math.abs(createdHandle.startY - newY) > 5) {
              createdHandle.handle.style.display = '';
              createdHandle = null;
            }
          }

        }
        update(true);
      }
    }

    function mouseUp (e) {
      up();
    }

    function touchUp (e) {
      up();
    }

    function up () {
      grid.style.display = "none";
      grid.innerHTML = '';
      previewContainer.classList.remove('mouse-down');
      if (dragging) {
        for (let i = 0; i < dragHandles.length; i++) {
          let dragHandle = dragHandles[i];
          dragHandle.classList.remove('dragging');
        }
        shape.classList.remove('dragging');
        selection.style.display = 'none';
        dragging = null;
        notDragging = null;
        update();

        shapeName.innerText = "";

        if (createdHandle) {
          const newX = parseFloat(createdHandle.handle.dataset.x);
          const newY = parseFloat(createdHandle.handle.dataset.y);
          const index = dragHandles.indexOf(createdHandle.handle);
          deleteHandle(createdHandle.handle);
          const before = (index - 1 + dragHandles.length) % dragHandles.length;
          const after = index % dragHandles.length;
          dragHandles[before].classList.add('selected');
          dragHandles[after].classList.add('selected');
          update();
        }
        createdHandle = null;

        createHistory();
      }
    }


    let oldPath = '';
    let oldFillRule = '';
    function updateSnipview () {
      const clipPathElements = dragHandles
        .map(function (handle) {
          let x = parseFloat(handle.dataset.x);
          let y = parseFloat(handle.dataset.y);

          if (units.value === '%') {
            x = x * 100 / cachedWidth;
            y = y * 100 / cachedHeight;
          }

          return [round2dp(x) + units.value + ' ' + round2dp(y) + units.value, -1, -1];
        });

      let clipPath = '';
      for (let i = 0; i < clipPathElements.length; i++) {
        if (i !== 0) {
          clipPath += ', ';
        }
        clipPathElements[i][1] = clipPath.length;
        clipPath += clipPathElements[i][0];
        clipPathElements[i][2] = clipPath.length;
      }

      const fillRuleString = fillRule.value === 'nonzero' ? '' : fillRule.value + ', ';

      // Fix a weird bug in chrome where the clip path doesn't get re-rendered if only the fill-rule changes
      if (fillRuleString !== oldFillRule && clipPath === oldPath) {
        shape.style.clipPath = '';
      }

      oldPath = clipPath;
      oldFillRule = fillRuleString;

      const clipPathString = 'polygon(' + fillRuleString + clipPath + ')';
      shape.style.clipPath = clipPathString;
      shape.style.backgroundSize = backgroundSize.value;
      backgroundImage.style.backgroundSize = shape.style.backgroundSize;

      for (let i = 0; i < clipPathElements.length; i++) {
        clipPathElements[i][1] = clipPathElements[i][1] + fillRuleString.length + 19;
        clipPathElements[i][2] = clipPathElements[i][2] + fillRuleString.length + 19;
      }

      if (!parsing) {
        nextHighlights = clipPathElements.map(function (e) { return [e[1], e[2]]; });
        nextOutput = 'clip-path: ' + clipPathString + ';';
        if (shape.style.background) {
          nextOutput += '\nbackground: ' + shape.style.background;
        } else {
          nextOutput += '\nbackground-color: ' + $('#cp2').colorpicker('getValue');
        }
        maybeUpdateOutput();
      }
    }

    let textHighlights = [];
    let nextHighlights = [];
    let nextOutput = '';
    let outputTimeout = createTimeout();
    function maybeUpdateOutput () {
      outputTimeout.clear();
      outputTimeout = createTimeout(displayOutput, 20);
    }

    function displayOutput () {
      outputTimeout.clear();
      outputPre.innerHTML = nextOutput;
      oldText = nextOutput;
      Prism.highlightElement(outputPre);
      textHighlights = [];
      for (let i = 0; i < nextHighlights.length; i++) {
        const start = nextHighlights[i][0];
        const end = nextHighlights[i][1];
        createHighlight(outputPre, start, end, i);
      }
    }

    function createHighlight (element, start, end, index, rangePosition) {
      rangePosition = rangePosition || 0;
      for (let i = 0; i < element.childNodes.length; i++) {
        const node = element.childNodes[i];
        if (!node.hasChildNodes()) {
          const endPosition = rangePosition + node.textContent.length;
          if (start >= rangePosition && end <= endPosition) {
            const nodeStart = start - rangePosition;
            const nodeEnd = end - rangePosition;
            const before = document.createTextNode(node.textContent.substring(0, nodeStart));
            const middle = document.createElement('span');
            middle.innerText = node.textContent.substring(nodeStart, nodeEnd);
            middle.classList.add('handle-text');
            middle.style.color = handleColor(index);
            if (dragHandles[index].classList.contains('selected')) {
              middle.classList.add('selected');
            }
            const after = document.createTextNode(node.textContent.substring(nodeEnd));
            node.parentElement.insertBefore(before, node);
            node.parentElement.insertBefore(middle, node);
            node.parentElement.insertBefore(after, node);
            node.parentElement.removeChild(node);
            textHighlights.push(middle);

            middle.addEventListener('mouseenter', function () {
              dragHandles[index].classList.add('text-hover');
            });
            middle.addEventListener('mouseleave', function () {
              dragHandles[index].classList.remove('text-hover');
            });
            return [true, endPosition];
          }
          rangePosition = endPosition;
        } else {
          const result = createHighlight(node, start, end, index, rangePosition);
          if (result[0]) {
            return result[0];
          } else {
            rangePosition = result[1];
          }
        }
      }
      return [false, rangePosition];
    }


    function getName (gridItem) {
      if (gridItem.names && gridItem.names.length > 0) {
        if (gridItem.noMergeNames) {
          return gridItem.names[0];
        }
        const sorted = gridItem.names.concat();
        sorted.sort();
        removeSortedDuplicates(sorted);
        return sorted.join(' and ');
      }
      return '';
    }

    function displayGridCircle (circle, onlyHighlight) {
      const element = document.createElement('div');
      element.classList.add('circle');
      element.style.margin = "-" + circle.circle[1] + "px";
      element.style.left = circle.circle[0][0] + "px";
      element.style.top = circle.circle[0][1] + "px";
      element.style.width = (circle.circle[1] * 2) + "px";
      element.style.height = (circle.circle[1] * 2) + "px";
      element.dataset.for = getName(circle);

      if (onlyHighlight) {
        element.dataset.onlyhighlight = true;
        element.classList.add('highlight');
      }

      circle.element = element;

      grid.appendChild(element);
    }

    function displayGridLine (line, onlyHighlight) {
      const element = document.createElement('div');
      element.classList.add('line');
      line.element = element;

      repositionLine(line);
      element.dataset.for = getName(line);

      if (onlyHighlight) {
        element.dataset.onlyhighlight = true;
        element.classList.add('highlight');
      }

      grid.appendChild(element);
    }

    function repositionLine (line) {
      line.dynamic = line.line[0].dataset || line.line[1].dataset;

      const p1x = line.line[0].dataset ? parseFloat(line.line[0].dataset.x) : line.line[0][0];
      const p1y = line.line[0].dataset ? parseFloat(line.line[0].dataset.y) : line.line[0][1];
      const p2x = line.line[1].dataset ? parseFloat(line.line[1].dataset.x) : line.line[1][0];
      const p2y = line.line[1].dataset ? parseFloat(line.line[1].dataset.y) : line.line[1][1];
      const a = p2x - p1x;
      const b = p2y - p1y;
      const rotate = Math.atan2(p2x - p1x, p1y - p2y);

      if (line.infinite || line.infinite === undefined) {
        line.element.style.transform = "translate(" + p1x + "px, " + p1y + "px) rotate(" + rotate + "rad) scaleX(0.5) translate(-50%, -5000px)";
      } else {
        const length = Math.round(Math.sqrt(a * a + b * b));
        line.element.style.transform = "translate(" + p1x + "px, " + p1y + "px) rotate(" + (rotate + Math.PI) + "rad) scaleX(0.5) translateX(-50%)";
        line.element.style.height = length + 'px';
      }
    }

    function displayGridPoint (point, onlyHighlight) {
      const element = document.createElement('div');
      element.classList.add('point');
      element.style.left = point.point[0] + "px";
      element.style.top = point.point[1] + "px";
      element.dataset.for = getName(point);

      if (onlyHighlight) {
        element.dataset.onlyhighlight = true;
        element.classList.add('highlight');
      }

      point.element = element;

      grid.appendChild(element);
    }

    function displayGridRightAngle (rightAngle, onlyHighlight) {
      const element = document.createElement('div');
      element.classList.add('right-angle');
      rightAngle.element = element;

      repositionRightAngle(rightAngle);
      element.dataset.for = getName(rightAngle);

      if (onlyHighlight) {
        element.dataset.onlyhighlight = true;
        element.classList.add('highlight');
      }

      grid.appendChild(element);
    }

    function repositionRightAngle (rightAngle) {
      rightAngle.dynamic = rightAngle.rightAngle[0].dataset || rightAngle.rightAngle[1].dataset || rightAngle.rightAngle[2].dataset;
      const p1x = rightAngle.rightAngle[0].dataset ? parseFloat(rightAngle.rightAngle[0].dataset.x) : rightAngle.rightAngle[0][0];
      const p1y = rightAngle.rightAngle[0].dataset ? parseFloat(rightAngle.rightAngle[0].dataset.y) : rightAngle.rightAngle[0][1];
      const p2x = rightAngle.rightAngle[1].dataset ? parseFloat(rightAngle.rightAngle[1].dataset.x) : rightAngle.rightAngle[1][0];
      const p2y = rightAngle.rightAngle[1].dataset ? parseFloat(rightAngle.rightAngle[1].dataset.y) : rightAngle.rightAngle[1][1];
      const p3x = rightAngle.rightAngle[2].dataset ? parseFloat(rightAngle.rightAngle[2].dataset.x) : rightAngle.rightAngle[2][0];
      const p3y = rightAngle.rightAngle[2].dataset ? parseFloat(rightAngle.rightAngle[2].dataset.y) : rightAngle.rightAngle[2][1];

      const rotateA = Math.atan2(p3x - p2x, p2y - p3y);
      const rotateB = Math.atan2(p2x - p1x, p1y - p2y);
      const diff = (rotateA - rotateB);

      let angle;
      if (diff < -Math.PI || diff > 0 && diff < Math.PI) {
        angle = rotateA - Math.PI / 2;
      } else {
        angle = rotateB + Math.PI / 2;
      }

      rightAngle.element.style.transform = 'translate(' + p2x + 'px, ' + p2y + 'px) rotate(' + angle + 'rad)';
    }

    function displayGrid () {
      grid.innerHTML = '';
      for (let i = 0; i < snapCircles.length; i++) {
        displayGridCircle(snapCircles[i]);
      }
      for (let i = 0; i < snapLines.length; i++) {
        displayGridLine(snapLines[i]);
      }
      for (let i = 0; i < snapPoints.length; i++) {
        displayGridPoint(snapPoints[i]);
      }
    }

    function createHighlightElement (highlight) {
      if (highlight.line) {
        displayGridLine(highlight, true);
        return [highlight.element];
      } else if (highlight.point) {
        displayGridPoint(highlight, true);
        return [highlight.element];
      } else if (highlight.rightAngle) {
        displayGridRightAngle(highlight, true);
        return [highlight.element];
      }

      return [];
    }

    function repositionHighlightElement (highlight) {
      if (highlight.line) {
        repositionLine(highlight);
      } else if (highlight.rightAngle) {
        repositionRightAngle(highlight);
      }
    }

    function getHighlightElements (highlights) {
      return highlights.flatMap(function (highlight) {
        const e = highlight.element ? [highlight.element] : createHighlightElement(highlight);
        for (let i = 0; i < e.length; i++) {
          if (!e[i].parentElement) {
            grid.appendChild(e[i]);
          }
        }
        if (highlight.dynamic) {
          repositionHighlightElement(highlight);
        }
        const h = highlight.highlights && !highlight.noChildHighlights ? getHighlightElements(highlight.highlights) : [];
        const result = e.concat(h);
        removeDuplicates(result);
        return result;
      });
    }

    function highlightGrid (highlights) {
      const highlightedElements = getHighlightElements(highlights);

      const gridHighlights = grid.querySelectorAll('.highlight');
      for (let i = 0; i < gridHighlights.length; i++) {
        const element = gridHighlights[i];
        if (highlightedElements.indexOf(element) === -1) {
          if (element.dataset.onlyhighlight === 'true') {
            element.parentElement.removeChild(element);
          } else {
            element.classList.remove('highlight');
          }
        }
      }

      for (let i = 0; i < highlightedElements.length; i++) {
        const highlight = highlightedElements[i];
        if (!highlight.classList.contains('highlight')) {
          highlight.classList.add('highlight');
        }
      }
    }

    function removeHighlights () {
      const highlights = grid.querySelectorAll('.highlight');
      for (let i = 0; i < highlights.length; i++) {
        const element = highlights[i];
        if (element.dataset.onlyhighlight === 'true') {
          element.parentElement.removeChild(element);
        } else {
          element.classList.remove('highlight');
        }
      }
    }

    function maybeSnap (p) {
      let closestPoint = null;
      const maybeSnaps = pointsIndex.query(new QT.Box(p[0] - snapDistance, p[1] - snapDistance, p[0] + snapDistance, p[1] + snapDistance));
      for (let i = 0; i < maybeSnaps.length; i++) {
        if (isInBounds(maybeSnaps[i].point)) {
          const distance = vec2.distance(p, maybeSnaps[i].point);
          if (distance < snapDistance && (!closestPoint || distance < closestPoint.distance)) {
            closestPoint = {
              distance: distance,
              point: maybeSnaps[i].point,
              names: maybeSnaps[i].names,
              noMergeNames: maybeSnaps[i].noMergeNames,
              highlights: [maybeSnaps[i]]
            };
          }
        }
      }

      if (closestPoint) {
        shapeName.innerText = getName(closestPoint);
        highlightGrid(closestPoint.highlights);
        return closestPoint.point;
      }

      let closest = null;
      for (let i = 0; i < snapLines.length; i++) {
        let snapPoint = pointOnLineClosestToAnotherPoint(snapLines[i], p);

        if (snapPoint && isInBounds(snapPoint)) {
          const distance = vec2.distance(p, snapPoint);
          if (distance < snapDistance && (!closest || distance < closest.distance)) {
            closest = {
              distance: distance,
              point: snapPoint,
              names: snapLines[i].names,
              noMergeNames: snapLines[i].noMergeNames,
              highlights: [snapLines[i]]
            };
          }
        }
      }

      for (let i = 0; i < snapCircles.length; i++) {
        let snapPoint = closestPointOnCircle(snapCircles[i].circle, p);

        if (isInBounds(snapPoint)) {
          const distance = vec2.distance(p, snapPoint);
          if (distance < snapDistance && (!closest || distance < closest.distance)) {
            closest = {
              distance: distance,
              point: snapPoint,
              names: snapCircles[i].names,
              noMergeNames: snapCircles[i].noMergeNames,
              highlights: [snapCircles[i]]
            };
          }
        }
      }

      if (closest) {
        shapeName.innerText = getName(closest);
        highlightGrid(closest.highlights);
        return closest.point;
      }

      shapeName.innerText = "";
      removeHighlights();
      return p;
    }

    function isInBounds (point) {
      return point[0] >= 0 && point[1] >= 0 && point[0] <= cachedWidth && point[1] <= cachedHeight;
    }

    function getPerpendicularLine (pointA, pointB, position) {
      let centralPoint = vec2.add([], pointA, vec2.scale([], vec2.subtract([], pointB, pointA), position));

      transform = mat2d.fromTranslation([], centralPoint);
      transform = mat2d.rotate([], transform, Math.PI / 2);
      transform = mat2d.translate([], transform, vec2.negate([], centralPoint));

      let rotatedA = vec2.transformMat2d([], pointA, transform);
      let rotatedB = vec2.transformMat2d([], pointB, transform);

      return [rotatedA, rotatedB];
    }

    function getHorizontalLine (point) {
      return [point, [point[0] + 100, point[1]]];
    }

    function getVerticalLine (point) {
      return [point, [point[0], point[1] + 100]];
    }

    function findEquilateralPointA (pointA, pointB) {
      const c2 = rotatePoint(pointB, -Math.PI / 3, pointA);
      return [c1, c2];
    }

    function collinear (p1, p2, p3) {
      return Math.abs((p1[1] - p2[1]) * (p1[0] - p3[0]) - (p1[1] - p3[1]) * (p1[0] - p2[0])) < 0.0001;
    }

    function lineCircleIntersection (line, circle, lineIsInfinite) {
      const lineIsSegment = lineIsInfinite !== undefined && !lineIsInfinite;
      let p1x = line[0][0];
      let p1y = line[0][1];
      let p2x = line[1][0];
      let p2y = line[1][1];
      let scx = circle[0][0];
      let scy = circle[0][1];
      let r = circle[1];

      let dpx = p2x - p1x;
      let dpy = p2y - p1y;

      let a = dpx * dpx + dpy * dpy;
      let b = 2 * (dpx * (p1x - scx) + dpy * (p1y - scy));
      let c = scx * scx + scy * scy;
      c += p1x * p1x + p1y * p1y;
      c -= 2 * (scx * p1x + scy * p1y);
      c -= r * r;
      let bb4ac = b * b - 4 * a * c;
      if (Math.abs(a) <= Number.EPSILON || bb4ac < 0) {
        // No intersection
        return []
      }

      let sqbb4ac = Math.sqrt(bb4ac);
      let mu1 = (-b + sqbb4ac) / (2 * a)
      let mu2 = (-b - sqbb4ac) / (2 * a);

      let i1 = [p1x + mu1 * (p2x - p1x), p1y + mu1 * (p2y - p1y)];
      if (Math.abs(sqbb4ac) <= Number.EPSILON) {
        // Line is a tangent

        if (lineIsSegment && (mu1 < 0 || mu1 > 1)) {
          // The tangent is outside the line segment
          return [];
        }

        // The tangent is inside the line segment
        return [i1];
      }

      let i2 = [p1x + mu2 * (p2x - p1x), p1y + mu2 * (p2y - p1y)];

      if (lineIsSegment) {
        if (mu1 >= 0 && mu1 <= 1) {
          if (mu2 >= 0 && mu2 <= 1) {
            // i1 and i2 are inside the line segment
            return [i1, i2];
          }
          // i1 is inside the line segment
          return [i1];
        }

        if (mu2 >= 0 && mu2 <= 1) {
          // i2 is inside the line segment
          return [i2]
        }

        // i1 and i2 are outside the line segment
        return []
      }

      return [i1, i2];
    }

    function circleCircleIntersection (circle1, circle2) {
      // http://paulbourke.net/geometry/circlesphere/
      let X1 = circle1[0][0];
      let Y1 = circle1[0][1];
      let X2 = circle2[0][0];
      let Y2 = circle2[0][1];
      let R1 = circle1[1];
      let R2 = circle2[1];

      let Dx = X2 - X1;
      let Dy = Y2 - Y1;

      // Distance between circle centres
      let D = Math.sqrt(Dx * Dx + Dy * Dy);

      if (D > R1 + R2) {
        return []; // The circles do not intersect
      } else if (D < Math.abs(R2 - R1)) {
        return []; //No Intersect - One circle is contained within the other
      } else if (D == 0 && R1 == R2) {
        return []; //No Intersect - The circles are equal and coincident
      } else {
        let chorddistance = (R1 * R1 - R2 * R2 + D * D) / (2 * D);

        // distance from 1st circle's centre to the chord between intersects
        let halfchordlength = Math.sqrt(R1 * R1 - chorddistance * chorddistance);
        let chordmidpointx = X1 + (chorddistance * Dx) / D;
        let chordmidpointy = Y1 + (chorddistance * Dy) / D;
        let I1 = [chordmidpointx + (halfchordlength * Dy) / D,
        chordmidpointy - (halfchordlength * Dx) / D];
        //let theta1 = Math.atan2(I1[1] - Y1, I1[0] - X1);

        let I2 = [chordmidpointx - (halfchordlength * Dy) / D,
        chordmidpointy + (halfchordlength * Dx) / D];
        //let theta2 = Math.atan2(I2[1] - Y1, I2[0] - X1);

        /*if (theta2 > theta1) {
            let swap = I2;
            I2 = I1;
            I1 = swap;
        }*/

        if (D == R1 + R2 || D == R1 - R2) {
          // "The circles intersect at a single point"
          return [I1];
        } else {
          // "The circles intersect at two points"
          return [I1, I2];
        }
      }
    }

    function lineLineIntersection (line1, line2, line1IsInfinite, line2IsInfinite) {
      const line1IsSegment = line1IsInfinite !== undefined && !line1IsInfinite;
      const line2IsSegment = line2IsInfinite !== undefined && !line2IsInfinite;
      const x1 = line1[0][0];
      const y1 = line1[0][1];
      const x2 = line1[1][0];
      const y2 = line1[1][1];
      const x3 = line2[0][0];
      const y3 = line2[0][1];
      const x4 = line2[1][0];
      const y4 = line2[1][1];

      const d = ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));

      if (d === 0) {
        // Lines are parallel
        return [];
      }

      const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / d;
      const u = line2IsSegment ? ((x1 - x3) * (y1 - y2) - (y1 - y3) * (x1 - x2)) / d : 0;

      if (line1IsSegment && (t < 0 || t > 1)) {
        return [];
      }

      if (line2IsSegment && (u < 0 || u > 1)) {
        return [];
      }

      const intersectionPoint = [
        x1 + t * (x2 - x1),
        y1 + t * (y2 - y1)
      ];

      return [intersectionPoint];
    }

    function pointOnLineClosestToAnotherPoint (line, point) {
      let lineDirection = vec2.subtract([], line.line[0], line.line[1]);

      let rotate90 = mat2.fromValues(0, 1, -1, 0);
      let perpendicular = vec2.transformMat2([], lineDirection, rotate90);
      let line2 = [point, vec2.add([], point, perpendicular)];

      const intersection = lineLineIntersection(line2, line.line, true, line.infinite);
      if (intersection.length > 0) {
        return intersection[0];
      }
      return null;
    }

    function closestPointOnCircle (circle, point) {
      let direction = vec2.subtract([], point, circle[0]);
      let normalizedDirection = vec2.normalize([], direction);
      let fromCentre = vec2.scale([], normalizedDirection, circle[1]);
      let pointOnCircle = vec2.add([], circle[0], fromCentre);
      return pointOnCircle;
    }

    function closestPointOnCircle (circle, point) {
      let direction = vec2.subtract([], point, circle[0]);
      let normalizedDirection = vec2.normalize([], direction);
      let fromCentre = vec2.scale([], normalizedDirection, circle[1]);
      let pointOnCircle = vec2.add([], circle[0], fromCentre);
      return pointOnCircle;
    }

    function getRightAngleCircle (pointA, pointB) {
      let radiusLine = vec2.scale([], vec2.subtract([], pointA, pointB), 0.5);
      let midPoint = vec2.add([], pointB, radiusLine);
      let radius = vec2.length(radiusLine);
      return [midPoint, radius];
    }

    function getIsocelesCircle (pointA, pointB) {
      let radiusLine = vec2.subtract([], pointA, pointB);
      let radius = vec2.length(radiusLine);
      return [pointA, radius];
    }

    function isAbove (a, b, p) {
      let d = (b[0] - a[0]) * (b[1] - p[1]) - (b[1] - a[1]) * (b[0] - p[0]);
      return d > 0;
    }

    function angleToHorizontal (a, b) {
      let edge = Math.atan2(a[0] - b[0], b[1] - a[1]);
      return -Math.PI / 2 - edge;
    }

    function rotatePoint (point, angle, originPoint = null) {
      if (!originPoint) {
        originPoint = [0, 0];
      }

      return vec2.rotate([], point, originPoint, angle);
    }


    document.querySelectorAll('.example').forEach(function (example) {
      setExampleStyle(example);
      example.addEventListener('click', function () {
        applyExample(example);
      });
    });

    $('#cp2').colorpicker({
      customClass: 'colorpicker-2x',
      sliders: {
        saturation: {
          maxLeft: 218,
          maxTop: 200
        },
        hue: {
          maxTop: 200
        },
        alpha: {
          maxTop: 200
        }
      }
    })
      .on('changeColor', function (e) {
        shape.style.background = '';
        backgroundImage.style.background = '';
        shape.style.backgroundColor = e.color.toString();
        update();
        maybeCreateHistory();
      });

    function initDefault () {
      clearHandles();
      createHandle(100, 100);
      createHandle(300, 100);
      createHandle(300, 300);
      createHandle(100, 300);
      shape.style.background = '';
      backgroundImage.style.background = '';
      $('#cp2').colorpicker('setValue', '#000000');
      backgroundSize.value = 'cover';
      units.value = '%';
      fillRule.value = 'nonzero';
      update();
      createHistory();
    }

    const imageCache = {};
    function cacheHistoryImage (image) {
      if (!image) {
        return null;
      }

      const found = Object.keys(imageCache).filter(function (key) {
        return imageCache[key] === image;
      });
      if (found.length > 0) {
        return found[0];
      }

      const id = (Math.random() + 1).toString(36).substring(2);
      imageCache[id] = image;
      return id;
    }

    function afterHistory () {
      const used = history.map(function (item) {
        return item.backgroundImage;
      });

      Object.keys(imageCache).forEach(function (key) {
        if (!used.includes(key)) {
          delete imageCache[key];
        }
      });
    }


    function updateCachedSize () {
      const windowWidth = window.innerWidth;
      if (!cachedWindowWidth || windowWidth != cachedWindowWidth) {
        if (cachedWidth != previewContainer.clientWidth || cachedHeight != previewContainer.clientHeight) {
          cachedWidth = previewContainer.clientWidth;
          cachedHeight = previewContainer.clientHeight;
          recreateIndex();
        }
        cachedWindowWidth = windowWidth;
      }
    }

    function update (noHighlight) {
      updateSnipview();
    }



    function keyDown (e) {
      if (e.keyCode === 16) {
        shapeName.innerText = "";
        grid.style.display = "none";
      }
    }

    function keyUp (e) {
      if (e.keyCode === 16 && snap.checked && dragging) {
        grid.style.display = "block";
      }
    }

    function recreateIndex () {
      let oldPoints = [];
      if (pointsIndex) {
        oldPoints = pointsIndex.getAllPoints();
      }

      const bounds = new QT.Box(0, 0, cachedWidth, cachedHeight);
      const config = {
        capacity: 1000,
        removeEmptyNodes: true,
        maximumDepth: 5,
      };

      pointsIndex = new QT.QuadTree(bounds, config, oldPoints);
    }

    function createHistoryItem () {
      const historyItem = {
        handles: dragHandles.map(function (handle) {
          return {
            x: parseFloat(handle.dataset.x),
            y: parseFloat(handle.dataset.y)
          };
        })
      }

      historyItem.backgroundImage = cacheHistoryImage(shape.style.backgroundImage);
      historyItem.backgroundColor = $('#cp2').colorpicker('getValue');
      historyItem.backgroundSize = backgroundSize.value;
      historyItem.units = units.value;
      historyItem.fillRule = fillRule.value;
      historyItem.width = cachedWidth;
      historyItem.height = cachedHeight;

      return historyItem;
    }

    function applyHistoryItem (historyItem) {

      previewWidth.value = historyItem.width;
      previewHeight.value = historyItem.height;
      changeSize();


      for (let i = 0; i < historyItem.handles.length; i++) {
        if (dragHandles.length <= i) {
          createHandle(historyItem.handles[i].x, historyItem.handles[i].y);
        } else {
          dragHandles[i].dataset.x = historyItem.handles[i].x,
            dragHandles[i].dataset.y = historyItem.handles[i].y
        }
        dragHandles[i].style.transform = "translate(" + historyItem.handles[i].x + "px, " + historyItem.handles[i].y + "px)";
      }
      while (dragHandles.length > historyItem.handles.length) {
        deleteHandle(dragHandles[dragHandles.length - 1]);
      }


      $('#cp2').colorpicker('setValue', historyItem.backgroundColor);
      if (historyItem.backgroundImage) {
        shape.style.background = imageCache[historyItem.backgroundImage];
        backgroundImage.style.background = shape.style.background;
      }
      backgroundSize.value = historyItem.backgroundSize;
      units.value = historyItem.units;
      fillRule.value = historyItem.fillRule;


      update();
    }

    function historyMatches (item1, item2) {
      if (item1.handles.length !== item2.handles.length) {
        return false;
      }

      for (let i = 0; i < item1.handles.length; i++) {
        if (item1.handles[i].x !== item2.handles[i].x || item1.handles[i].y !== item2.handles[i].y) {
          return false;
        }
      }


      if (item1.backgroundImage !== item2.backgroundImage) {
        return false;
      }

      if (item1.backgroundSize !== item2.backgroundSize) {
        return false;
      }

      if (item1.backgroundColor !== item2.backgroundColor) {
        return false;
      }

      if (item1.units !== item2.units) {
        return false;
      }

      if (item1.fillRule !== item2.fillRule) {
        return false;
      }


      return true;
    }



    function getLinkData () {
      let widthMultiplier = 1;
      let heightMultiplier = 1;


      if (units.value === '%') {
        widthMultiplier = 100 / cachedWidth;
        heightMultiplier = 100 / cachedHeight;
      }


      let code = dragHandles.map(function (h) {
        const x = round3dp(parseFloat(h.dataset.x) * widthMultiplier);
        const y = round3dp(parseFloat(h.dataset.y) * heightMultiplier);
        return x + ':' + y;
      }).join(',');
      let version = '2';


      code = code + ';' + (units.value === '%' ? '' : 'px');
      code = code + ';' + (fillRule.value === 'nonzero' ? '' : fillRule.value);
      code = code + ';' + $('#cp2').colorpicker('getValue');


      return [version, code];
    }

    // 分享
    function getLink () {
      let linkData = getLinkData();

      let data = '';
      const encoded = btoa(linkData[1]).replace(/=/g, '');
      const compressed = LZString.compressToEncodedURIComponent(linkData[1]).replace(/=/g, '');

      if (encoded.length <= compressed.length) {
        data = '1' + linkData[0] + encoded;
      } else {
        data = '2' + linkData[0] + compressed;
      }

      return window.location.origin + window.location.pathname + '?p=' + data;
    }

    shape.addEventListener("mousedown", mouseDown, { passive: false });
    shape.addEventListener("touchstart", touchDown, { passive: false });
    previewContainer.addEventListener("mousedown", mouseDown, { passive: false });
    previewContainer.addEventListener("touchstart", touchDown, { passive: false });
    document.addEventListener("mousemove", mouseMove, { passive: true });
    document.addEventListener("mouseup", mouseUp, { passive: false });
    document.addEventListener("touchmove", touchMove, { passive: true });
    document.addEventListener("touchend", touchUp, { passive: false });
    document.addEventListener("keydown", keyDown);
    document.addEventListener("keyup", keyUp);

    const touch = "ontouchstart" in document.documentElement;
    document.body.classList.add(touch ? 'touch' : 'no-touch');

    if (window.ResizeObserver) {
      new ResizeObserver(updateCachedSize).observe(previewContainer);
    } else {
      window.addEventListener("resize", updateCachedSize);
    }

    function decompressPrefill (param) {
      const compressionVersion = parseInt(param[1].substring(0, 1));
      const prefillVersion = parseInt(param[1].substring(1, 2))
      const code = param[1].substring(2);
      switch (compressionVersion) {
        case 1: // No compression, just base64
          return [prefillVersion, atob(code)];
        case 2: // LZString
          return [prefillVersion, LZString.decompressFromEncodedURIComponent(code)];
      }
      return null;
    }


    function getSelectionOffsetRelativeTo (parentElement, currentNode) {
      var currentSelection, currentRange,
        startOffset = 0,
        endOffset = 0,
        prevSibling,
        nodeContent;

      if (!currentNode) {
        currentSelection = window.getSelection();
        if (currentSelection.rangeCount === 0) {
          return false;
        }
        currentRange = currentSelection.getRangeAt(0);
        currentNode = currentRange.startContainer;
        startOffset += currentRange.startOffset;
        endOffset += currentRange.endOffset;
      }

      if (currentNode === parentElement) {
        return [startOffset, endOffset];
      }

      if (!parentElement.contains(currentNode)) {
        return false;
      }

      while (prevSibling = (prevSibling || currentNode).previousSibling) {
        nodeContent = prevSibling.innerText || prevSibling.nodeValue || "";
        startOffset += nodeContent.length;
        endOffset += nodeContent.length;
      }

      const parentOffsets = getSelectionOffsetRelativeTo(parentElement, currentNode.parentNode);

      return [startOffset + parentOffsets[0], startOffset + parentOffsets[1]];
    }

    function getElementPosition (parentElement, currentNode) {
      var currentSelection, currentRange,
        startOffset = 0,
        prevSibling,
        nodeContent;

      if (currentNode === parentElement) {
        return startOffset;
      }

      if (!parentElement.contains(currentNode)) {
        return false;
      }

      while (prevSibling = (prevSibling || currentNode).previousSibling) {
        nodeContent = prevSibling.innerText || prevSibling.nodeValue || "";
        startOffset += nodeContent.length;
      }

      const parentOffset = getElementPosition(parentElement, currentNode.parentNode);

      return startOffset + parentOffset;
    }

    function setRange (element, range, start, end, rangePosition, startSet, endSet) {
      rangePosition = rangePosition || 0;
      for (let i = 0; i < element.childNodes.length && !startSet && !endSet; i++) {
        const node = element.childNodes[i];
        if (!node.hasChildNodes()) {
          const endPosition = rangePosition + node.textContent.length;
          if (!startSet && rangePosition <= start && endPosition >= start) {
            startSet = true;
            range.setStart(node, start - rangePosition);
          }
          if (!endSet && rangePosition <= end && endPosition >= end) {
            endSet = true;
            range.setEnd(node, end - rangePosition);
          }
          rangePosition = endPosition;
        } else {
          const result = setRange(node, range, start, end, rangePosition, startSet, endSet);
          rangePosition = result[0];
          startSet = result[1];
          endSet = result[1];
        }
      }
      return [rangePosition, startSet, endSet];
    }

    function applyPrefill (version, code) {

      if (version === 1) {
        if (code.endsWith(';')) {
          code = code.substring(0, code.length - 1);
        }
        let ast = csstree.parse(code);
        let match = csstree.lexer.matchProperty('clip-path', ast);
        if (match.matched) {
          ast = csstree.parse('*{clip-path:' + code + '}');
        }

        let clipPath = csstree.findLast(ast, function (node, item, list) {
          return node.type === 'Declaration' && node.property === 'clip-path';
        });

        if (!clipPath) {
          ast = csstree.parse('*{' + code + '}');
          clipPath = csstree.findLast(ast, function (node, item, list) {
            return node.type === 'Declaration' && node.property === 'clip-path';
          });
        }

        if (!clipPath) {
          return false;
        }

        match = csstree.lexer.matchProperty('clip-path', clipPath.value);
        if (!match.matched) {
          return false;
        }

        if (match.matched.match[0].match[0].syntax.name !== 'polygon()') {
          return false;
        }

        const polygon = match.matched.match[0].match[0].match;
        const points = [];
        let hasPercent = false;
        let hasPx = false;
        let nextPoint = [0, 0];
        let nextPointIndex = 0;
        let newFillRule = 'nonzero';
        for (let i = 0; i < polygon.length; i++) {
          if (polygon[i].syntax.name === 'fill-rule') {
            newFillRule = polygon[i].match[0].node.name;
          } else if (polygon[i].syntax.name === 'length-percentage') {
            if (nextPointIndex > 1) {
              return false;
            }
            nextPoint[nextPointIndex] = parseFloat(polygon[i].match[0].match[0].node.value);
            if (polygon[i].match[0].syntax.name === 'percentage') {
              hasPercent = true;
            } else if (polygon[i].match[0].syntax.name === 'length' && polygon[i].match[0].match[0].node.unit == 'px') {
              hasPx = true;
            } else if (nextPoint[nextPointIndex] !== 0) {
              return false;
            }
            if (nextPointIndex == 1) {
              points.push(nextPoint);
            }
            nextPointIndex++;
          } else if (polygon[i].syntax.comma) {
            nextPoint = [0, 0];
            nextPointIndex = 0;
          }
        }

        if (hasPercent && hasPx) {
          return false;
        } else if (hasPx) {
          units.value = 'px';
        } else {
          units.value = '%';
        }

        fillRule.value = newFillRule;

        clearHandles();
        for (let i = 0; i < points.length; i++) {
          let x = points[i][0];
          let y = points[i][1];
          if (hasPercent) {
            x = x * cachedWidth / 100;
            y = y * cachedHeight / 100;
          }

          if (dragHandles.length > i) {
            dragHandles[i].dataset.x = x;
            dragHandles[i].dataset.y = y;
            dragHandles[i].style.transform = "translate(" + x + "px, " + y + "px)";
          } else {
            createHandle(x, y);
          }
        }
        while (dragHandles.length > points.length) {
          deleteHandle(dragHandles[dragHandles.length - 1]);
        }

        let newBackgroundSize = 'cover';
        csstree.walk(ast, function (node) {
          if (node.type === 'Declaration' && (node.property === 'background' || node.property === 'background-color' || node.property === 'background-image')) {
            const bgMatch = csstree.lexer.matchProperty('color', node.value);
            if (bgMatch.matched) {
              $('#cp2').colorpicker('setValue', csstree.generate(node.value));
            } else {
              shape.style.background = csstree.generate(node.value);
              shape.style.backgroundColor = '';
            }
          } else if (node.type === 'Declaration' && node.property === 'background-size') {
            const newValue = csstree.generate(node.value);
            if (newValue === 'cover' || newValue === 'contain' || newValue === 'auto') {
              newBackgroundSize = newValue;
            }
          }
        });
        backgroundSize.value = newBackgroundSize;

        return true;
      }

      if (version === 2) {
        clearHandles();
        const parts = code.split(';');
        const handles = parts[0].split(',');
        if (handles.length < 3) {
          return false;
        }
        let widthMultiplier = 1;
        let heightMultiplier = 1;


        units.value = parts[1] || '%';
        if (units.value === '%') {
          widthMultiplier = previewContainer.clientWidth / 100;
          heightMultiplier = previewContainer.clientHeight / 100;
        }


        let failed = false;
        handles.forEach(function (handle) {
          const coords = handle.split(':');

          if (coords.length !== 2) {
            failed = true;
          }
          const x = parseFloat(coords[0]) * widthMultiplier;
          const y = parseFloat(coords[1]) * heightMultiplier;
          createHandle(x, y);
        });


        fillRule.value = parts[2] || 'nonzero';
        $('#cp2').colorpicker('setValue', parts[3] || 'black');


        if (failed) {
          return false;
        }

        return true;
      }

      return false;
    }


    function parsePrefill (version, code, success, failure) {
      parsing = true;
      withCssTree(function () {
        const successful = applyPrefill(version, code);

        update();
        parsing = false;
        if (successful) {
          if (success) {
            success();
          }
        } else {
          if (failure) {
            failure();
          }
        }

        const selectionRange = getSelectionOffsetRelativeTo(outputPre);
        const newlines = outputPre.querySelectorAll('div')
        for (let i = 0; i < newlines.length; i++) {
          const position = getElementPosition(outputPre, newlines[i]);
          if (selectionRange[0] >= position) {
            selectionRange[0] = selectionRange[0] + 1;
          }
          if (selectionRange[1] >= position) {
            selectionRange[1] = selectionRange[1] + 1;
          }
          const parent = newlines[i].parentNode;
          parent.insertBefore(document.createTextNode('\n'), newlines[i]);
          while (newlines[i].firstChild) parent.insertBefore(newlines[i].firstChild, newlines[i]);
          parent.removeChild(newlines[i]);
        }
        Prism.highlightElement(outputPre, false, function () {
          if (selectionRange) {
            const range = document.createRange();
            setRange(outputPre, range, selectionRange[0], selectionRange[1]);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
          }
        });
      });
    }

    function applyFromText (text) {
      parsePrefill(1, text, function () {
        update();
        createHistory();
        clearHistory();
      });
    }

    function parseUrl (maybeSuccess, failed) {
      let prefill = window.location.hash.startsWith('#p=') ? window.location.hash.substring(3) : null;

      if (prefill) {
        prefill = decompressPrefill(['p', prefill]);
      }

      if (!prefill) {
        prefill = window.location.search
          .substring(1)
          .split('&')
          .map(function (param) { return param.split('='); })
          .filter(function (param) { return param[0] === 'p' && param[1]; })
          .map(decompressPrefill)
          .filter(function (param) { return param; })
          .shift();
      }

      if (prefill) {
        if (maybeSuccess) {
          maybeSuccess();
        }
        parsePrefill(prefill[0], prefill[1], function () {
          update();
          createHistory();
          clearHistory();
        }, failed);
      } else {
        if (failed) {
          failed();
        }
      }
    }

    function withCssTree (callback) {
      const script = document.getElementById('csstree-loaded');
      if (!script) {
        const resource = document.createElement('script');
        resource.src = "./static/js/csstree.807c0dcf2c46.js";
        resource.onload = resource.onreadystatechange = function () {
          resource.onload = resource.onreadystatechange = null;
          function waitForCssTree () {
            if (typeof csstree !== "undefined") {
              callback()
            } else {
              setTimeout(waitForCssTree, 100);
            }
          }
          waitForCssTree();
        };
        resource.id = 'csstree-loaded';
        document.head.appendChild(resource);
      } else {
        callback();
      }
    }


    let updateTimeout = -1;
    function edited () {
      clearTimeout(updateTimeout);
      updateTimeout = setTimeout(function () {
        if (outputPre.innerText !== oldText) {
          oldText = outputPre.innerText;
          parsePrefill(1, outputPre.innerText, function () {
            outputPre.classList.remove('invalid');
            outputPre.classList.add('valid');
          }, function () {
            outputPre.classList.remove('valid');
            outputPre.classList.add('invalid');
          });
        }
      }, 200);
    }
    outputPre.addEventListener('keyup', edited);

    outputPre.addEventListener('input', edited);
    outputPre.addEventListener('paste', function (e) {
      e.preventDefault();
      var text = (e.originalEvent || e).clipboardData.getData('text/plain');
      document.execCommand("insertHTML", false, text);
      edited();
    });


    document.addEventListener('DOMContentLoaded', function () {
      updateCachedSize();
      parseUrl(undefined, initDefault);
    });

    window.addEventListener('hashchange', function (e) {
      parseUrl(function () {
        e.preventDefault();
      });
    });
  </script>


  <script>
    $(function () {
      if (window.cookieconsent) {
        window.cookieconsent.hasTransition = false;
        window.cookieconsent.initialise({
          "palette": {
            "popup": {
              "background": "#edeff5",
              "text": "#838391"
            },
            "button": {
              "background": "#4b81e8"
            }
          },
          "theme": "edgeless",
          "content": {
            "href": "../pp-tos.html#pp"
          }
        })
      }
    });
  </script>

</body>